#!/bin/bash
###  commit message helper
###  luohao@uama.com.cn 2018 v0.1.0
###  jiayuhui@zhangyue.com 2019 v1.0.0
#######################################################################
###  <type>(<scope>): <subject>
###  <BLANK LINE>
###  <body>
###  <BLANK LINE>
###  <footer>
#######################################################################
###  allowed type:
###    feat:
###      新的功能特性
###      a new feature
###    fix:
###      BUG修复
###      a bug fix
###    docs:
###      文档更新
###      Documentation only changes
###    style:
###      与代码逻辑无关的样式修改（空格、格式、句尾结束符等）
###      Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
###    refactor:
###      代码重构，但与修复bug或者新功能无关
###      A code change that neither fixes a bug nor adds a feature
###    perf:
###      性能优化
###      A code change that improves performance
###    test:
###      测试用例
###      Adding missing tests
###    chore:
###      工程化更新（编译脚本、辅助工具等）
###      Changes to the build process or auxiliary tools and libraries such as documentation generation
#######################################################################
###  fix(#9527-commit|#9528|@9900-commit|@9000|module|file): SUBJECT TITLE
###
###  contents line1....
###  contents line2....
###
###  footer line...
#######################################################################
###  TODO:
###      nothing.
#######################################################################

set -u
# set -e

ZT_HOST=
ZT_USER=
ZT_PASS=

# 'xxx.xcodeproj/project.pbxproj' xcode 项目文件，用来查询版本号
PROJECT_XCODEPROJ_FILE=
# 'iOS_MARKETING_VERSION_BRANCH_NAME_build_XXXX' BUG解决的版本名称模板
# 其中 MARKETING_VERSION 换成版本号；BRANCH_NAME 换成分支名 (分支 feature/A/1 的名称是 1）
VERSION_NAME=

#GIT_PREVIOUS_SUCCESSFUL_COMMIT='a917c7a'
#GIT_COMMIT='e716e4e
GIT_COMMIT_INFO=
GIT_BRANCH_NAME=

DEBUG_LEVEL=0

COMMIT_CONTENT=
ENCODE_CONTENT=
COMMIT_SUBJECT=
COMMIT_TYPE=
COMMIT_SCOPE=

SCOPE_TASKS=
SCOPE_TASKS_NUM=

SCOPE_TASK_TYPE=
SCOPE_TASK_PARAM=
SCOPE_TASK_PARAMS=

ZT_LOGIN_OK=
ZT_SESSION=
ZT_SESSION_NAME=

_URL=
_RST=

_URL_CONTENT_TYPE="content-type: application/x-www-form-urlencoded"

ERR_SESSION_RST="[ERROR]101: Get session request error"
ERR_SESSION_DATA="[ERROR]102: Get session result error"
ERR_LOGIN="[ERROR]103: Shit happened when login to zentao with your account, please check account and password in this hook script [prepare-commit-msg] ."
ERR_NO_COMMIT="[INFO] No commits"
ERR_DEBUG="[ERROR]200: Debug breaking..."

#######################################################################

ERROR_CODE_NULL=1
ERROR_CODE_HEAD_FORMAT=2

#######################################################################
# util functions
#######################################################################
# remove \" in json, and echo value for given key

_parse_json_format(){
    echo "${1}" | sed 's/\\"/"/g' | sed 's/\\\\\\/\\/g' | sed 's/\\\\/\\/g'
}

_parse_json_meta_note_by_key(){
    _parse_json_format "${1}"  | sed -n "s/.*\"$2\":\({[^}]*}\).*/\1/p"
}

_parse_json_in_note_key_by_value(){
    _parse_json_meta_note_by_key "${1}"  "${2}" | sed -n "s/.*[,{]\"\([^\"]*\)\":\"$3\"[,}].*/\1/p"
}

_parse_json_in_note_value_by_key(){
    _parse_json_meta_note_by_key "${1}"  "${2}" | sed -n "s/.*\"$3\":\"\([^\"]*\).*/\1/p"
}

_parse_json_value_by_key(){
    echo $(_parse_json_format "${1}") | sed -n "s/.*\"$2\":\"\([^\"]*\).*/\1/p"
}

# simple url encode
_url_encode(){
    # echo "$1" | tr -d '\n' | xxd -plain | sed 's/\(..\)/%\1/g'
    # echo "$1" | tr -d '\n' | od -An -tx1 | tr ' ' %
    # _UE_P=$(python -c "import urllib; print urllib.quote('''$1''')")
    _UE_P="$(perl -MURI::Escape -e 'print uri_escape(join(" ",@ARGV));' "$1")"
    echo $_UE_P
}

# ouput more info when in debug mode
_curl_bin(){
    if [[ $DEBUG_LEVEL -gt 2 ]]; then
        echo "curl -k -X"
    else
        echo "curl -s -k -X"
    fi
}

_date_time(){
    echo `date "+%Y-%m-%d %H:%M:%S"`
}

_date_fmt(){
    echo `date "+%Y-%m-%d"`
}

log_exit(){
    echo -e "$(log_title) [INFO] $@"
    exit 0
}

log_info(){
    if [[ $DEBUG_LEVEL -gt 0 ]]; then
        echo -e "$(log_title) [INFO] $@"
    fi
}

log_debug(){
    if [[ $DEBUG_LEVEL -gt 1 ]]; then
        echo -e "$(log_title) [DEBUG] $@"
    fi
}

log_title(){
    if [[ $DEBUG_LEVEL -gt 1 ]]; then
        echo -e "$(_date_time) (GIT-HOOK)"
    else
        echo -e "(GIT-HOOK)"
    fi
}

#####################################################################

_git_commits() {
    git log --format="%s(%H)(%ae)(%ci)" "${GIT_PREVIOUS_SUCCESSFUL_COMMIT}..${GIT_COMMIT}"
}

_git_commit_head() {
    echo "${1}" | sed -n "s/^\(.*\)(.*)(.*)(.*)$/\1/p"
}

_git_commit_hash() {
    echo "${1}" | sed -n 's/^.*(\(.*\))(.*)(.*)$/\1/p'
}

_git_commit_auth() {
    echo "${1}" | sed -n 's/^.*(.*)(\(.*\))(.*)$/\1/p' | sed -n "s/\(.*\)@.*$/\1/p"
}

_git_commit_time() {
    echo "${1}" | sed -n 's/^.*(.*)(.*)(\(.*\))$/\1/p' | sed -n "s/\(.*\) +[0-9]\{4\}$/\1/p"
}

#####################################################################

_next_build_name(){
    # XCode 项目文件存在
    if [[ -f "$PROJECT_XCODEPROJ_FILE" ]]; then
        XCODEPROJ_CONTENT=`cat ${PROJECT_XCODEPROJ_FILE}`
        MARKETING_VERSION=`echo ${XCODEPROJ_CONTENT} | grep "MARKETING_VERSION = " | sed "s/.*MARKETING_VERSION = \([^;]*\).*/\1/"`
        GIT_BRANCH_NAME=`git branch | sed -n '/*/p' | sed "s/\* //;s/.*\/\(.*\)/\1/"`
        # GIT_BRANCH_NAME=`echo ${BRANCH_NAME} | sed "s/\* //;s/.*\/\(.*\)/\1/"`
        # if [[ ${GIT_BRANCH_NAME} == 'dev_jenkins' ]];then
        #     echo ${VERSION_NAME} | sed "s/MARKETING_VERSION/${MARKETING_VERSION}/" | sed "s/_BRANCH_NAME//"
        # else
        echo ${VERSION_NAME} | sed "s/MARKETING_VERSION/${MARKETING_VERSION}/" | sed "s/BRANCH_NAME/${GIT_BRANCH_NAME}/"
        # fi
    fi
}

#####################################################################
# validator
validator(){
    log_debug "validator..."
    # 是否有变更
    if [[ ${GIT_PREVIOUS_SUCCESSFUL_COMMIT} == ${GIT_COMMIT} ]];then
        log_exit ${ERR_NO_COMMIT}
    fi
    if [[ ${ZT_HOST} == "" || ${ZT_USER} == "" || ${ZT_PASS} == "" ]]; then
        log_info "zentao config error, skip scope magic."
    else
        # 读取提交消息内容
        _git_commits | while read GIT_COMMIT_INFO
        do
            COMMIT_CONTENT=`_git_commit_head "${GIT_COMMIT_INFO}"`
            ENCODE_CONTENT=${COMMIT_CONTENT}
            validate_base_format
            if [[ $? == 0 ]];then
                validate_scope_message
            fi
        done
    fi
}

validate_base_format(){
    # 校验整体格式是否合规
    ##########################################################
    # 1. 禁止空
    if [[ ${#COMMIT_CONTENT} -lt 1 ]]; then
        return ${ERROR_CODE_NULL}
    fi
    # 2. 格式是否正确: Type(scope): title
    if [[ ${COMMIT_CONTENT} =~ ^(feat|fix|docs|style|refactor|perf|test|chore)([\(]?[a-zA-Z0-9\.\#\@\|\-]*[\)]?)[[:blank:]]?:[[:blank:]]?(.*)$ ]]; then
        COMMIT_TYPE=${BASH_REMATCH[1]}
        COMMIT_SCOPE=${BASH_REMATCH[2]}
        COMMIT_SUBJECT=${BASH_REMATCH[3]}
    else
        return ${ERROR_CODE_HEAD_FORMAT}
    fi
}

# 校验socpe格式，处理多个任务
validate_scope_message(){
    if [[ ${#COMMIT_SCOPE} -lt 1 ]]; then
        log_info "no scope to process"
    # validate scope format and get scope content
    elif [[ ${COMMIT_SCOPE} =~ ^\(([\#\@]?[a-zA-Z0-9\.\#\@\|\-]*)\)$ ]]; then
        COMMIT_SCOPE_CONTENT=${BASH_REMATCH[1]}
        if [[ ${#COMMIT_SCOPE_CONTENT} -lt 2 ]]; then
            log_info "scope bad format less 2 ${COMMIT_SCOPE_CONTENT}"
        else
            # split to task array
            SCOPE_TASKS=(${COMMIT_SCOPE_CONTENT//|/ })
            log_debug "SCOPES ${SCOPE_TASKS}"
            SCOPE_TASKS_NUM=${#SCOPE_TASKS[@]}
            log_debug "SCOPES_NUM ${SCOPE_TASKS_NUM}"
            for ((i=0;i<$SCOPE_TASKS_NUM;i++)); do
                if [[ ${#SCOPE_TASKS[i]} -lt 2 ]]; then
                    log_info "scope task bad format less 2 ${SCOPE_TASKS[i]}"
                else
                    SCOPE_ITEM=${SCOPE_TASKS[i]}
                    if [[ ${SCOPE_ITEM} =~ ^[\#\@][0-9]*$ ]]; then
                        log_debug "task: ${SCOPE_ITEM}"
                        process ${SCOPE_ITEM}
                    else
                        log_info "scope: ${SCOPE_ITEM} isn't a bug or task."
                    fi
                fi
            done
        fi
    else
        log_info "scope bad format ${COMMIT_SCOPE}"
    fi
}

#####################################################################
# process tasks
process(){
    # get first chactor
    SCOPE_TASK_TYPE=`echo ${1:0:1}`
    log_debug "task type: ${SCOPE_TASK_TYPE}"
    # 截取除第一个字符的余下字符串
    SCOPE_TASK_PARAM=${1:1}
    log_debug "task param: ${SCOPE_TASK_PARAM}"
    if [[ "$SCOPE_TASK_TYPE" == "#" ]]; then
        # 处理bug
        process_bug_finish "${SCOPE_TASK_PARAM}"
    elif [[ "$SCOPE_TASK_TYPE" == "@" ]]; then
        # 处理任务
        process_feature_finish "${SCOPE_TASK_PARAM}"
    fi
}

#######################################################################

# 完成禅道bug
process_bug_finish(){
    log_debug "process bug finish $1"
    # 执行登录，如果已经登录则忽略
    do_login
    # 获取禅道BUG解决所需的信息 用时、抄送
    _URL="${ZT_HOST}?m=bug&f=edit&bugID=${1}&onlybody=yes&${ZT_SESSION_NAME}=${ZT_SESSION}&t=json"
    # get infomations that finish task needed.
    _RST=`$(_curl_bin) GET "${_URL}"`
    if echo "${_RST}" | grep -vw "success" &>/dev/null; then
        log_info "do resolve bug[${1}] error, unknow reason"
    fi
    BUG_STATUS=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "status")
    log_info "bug $1 is ${BUG_STATUS}"
    if [[ $BUG_STATUS != 'resolved' ]]; then
        CON_FINISH_ASSIGNED=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "assignedTo")
        PRODUCT=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "product")
        PROJECT=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "project")
        MODULE=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "module")
        PLAN=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "plan")
        STORY=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "story")
        TASK=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "task")
        RESOLVED_BUILD_ID='trunk'
        BUILD_NAME=$(_next_build_name)
        # echo "name: ${BUILD_NAME}"
        if [[ ! -z ${BUILD_NAME} ]];then
            RESOLVED_BUILD_ID=$(_parse_json_in_note_key_by_value "${_RST}" "resolvedBuilds" "${BUILD_NAME}")
            if [[ ! ${RESOLVED_BUILD_ID} =~ ^[0-9]+$ ]]; then
                RESOLVED_BUILD_ID='trunk'
                log_info "Don't find RESOLVED_BUILD_ID: ${BUILD_NAME}, set to default: trunk"
            fi
        fi
        OPENED_BUILD=$(_parse_json_in_note_value_by_key "${_RST}" "bug" "openedBuild")
        log_info "bug $1 begin with build: ${OPENED_BUILD}"
        if [[ ! -z ${OPENED_BUILD} ]];then
            ZT_RESOLVED_USER=$(_git_commit_auth "${GIT_COMMIT_INFO}")
            RESOLVED_USER_NAME=$(_parse_json_in_note_value_by_key "${_RST}" "users" "${ZT_RESOLVED_USER}")
            log_info "commited by: '${ZT_RESOLVED_USER}' who's name is '${RESOLVED_USER_NAME}'"
            if [[ ! -z ${RESOLVED_USER_NAME} ]]; then
                # 发送完成禅道任务的请求
                RESOLVED_DATE=$(_git_commit_time "${GIT_COMMIT_INFO}")
                COMMIT_HASH="<br>commit hash $(_git_commit_hash "${GIT_COMMIT_INFO}")"
                _URL_FORM_DATA="resolution=fixed&product=${PRODUCT}&project=${PROJECT}&module=${MODULE}&plan=${PLAN}&story=${STORY}&task=${TASK}&openedBuild[]=${OPENED_BUILD}&resolvedBuild=${RESOLVED_BUILD_ID}&resolvedBy=${ZT_RESOLVED_USER}&assignedTo=${CON_FINISH_ASSIGNED}&resolvedDate=${RESOLVED_DATE}&comment=${ENCODE_CONTENT}${COMMIT_HASH}"
                log_debug ${_URL_FORM_DATA}
                _RST=`$(_curl_bin) POST "${_URL}" -H "${_URL_CONTENT_TYPE}" -d "${_URL_FORM_DATA}"`
                # log_debug ${_RST}
                if echo "${_RST}" | grep -w "login" &>/dev/null; then
                    log_info "do resolve bug[${1}] error, need login"
                fi
            else
                log_info "${RESOLVED_USER_NAME}"
            fi
        else
            log_info "do not find opened build"
        fi
    else
        log_info "bug[${1}] had been resolved"
    fi
}

#######################################################################

# 完成禅道任务
process_feature_finish(){
    log_debug "process feature finish $1"
    # 执行登录，如果已经登录则忽略
    do_login
    # 获取禅道任务完成所需的信息 用时、抄送
    _URL="${ZT_HOST}?m=task&f=edit&taskID=${1}&onlybody=yes&${ZT_SESSION_NAME}=${ZT_SESSION}&t=json"
    # get infomations that finish task needed.
    _RST=`$(_curl_bin) GET "${_URL}"`
    if echo "${_RST}" | grep -vw "success" &>/dev/null; then
        log_info "do finish task[${1}] error, unknow reason"
    fi
    # log_debug ${_RST}
    TASK_STATUS=$(_parse_json_in_note_value_by_key "${_RST}" "task" "status")
    log_info "task $1 is ${TASK_STATUS}"
    if [[ $TASK_STATUS != 'done' ]]; then
        CON_FINISH_CONSUMED=$(_parse_json_in_note_value_by_key "${_RST}" "task" "consumed")
        CON_FINISH_ASSIGNED=$(_parse_json_in_note_value_by_key "${_RST}" "task" "assignedTo")
        # 发送完成禅道任务的请求
        _URL="${ZT_HOST}?m=task&f=finish&taskID=${1}&onlybody=yes&${ZT_SESSION_NAME}=${ZT_SESSION}&t=json"
        RESOLVED_DATE=$(_git_commit_time "${GIT_COMMIT_INFO}")
        COMMIT_HASH="<br>commit hash $(_git_commit_hash "${GIT_COMMIT_INFO}")"
        _URL_FORM_DATA="consumed=${CON_FINISH_CONSUMED}&assignedTo=${CON_FINISH_ASSIGNED}&finishedDate=${RESOLVED_DATE}&comment=${ENCODE_CONTENT}${COMMIT_HASH}"
        log_info "${_URL_FORM_DATA}"
        _RST=`$(_curl_bin) POST "${_URL}" -H "${_URL_CONTENT_TYPE}" -d "${_URL_FORM_DATA}"`
        log_debug ${_RST}
        if echo "${_RST}" | grep -w "login" &>/dev/null; then
            log_info "do finish task[${1}] error, need login"
        fi
    else
        log_info "task[${1}] had been done"
    fi
}

#######################################################################

# 登录禅道
do_login(){
    if [[ ${ZT_LOGIN_OK} == 1 ]]; then
        log_debug "already login"
    else
        do_get_session
        log_debug "login action begin"
        _URL="${ZT_HOST}?m=user&f=login&onlybody=yes&${ZT_SESSION_NAME}=${ZT_SESSION}&t=json"
        _RST=`$(_curl_bin) POST "${_URL}" -H "cache-control: no-cache" -H "content-type: application/x-www-form-urlencoded" -d "account=${ZT_USER}&password=${ZT_PASS}&keepLogin=on"`
        if [[ -z $_RST ]];then
            log_info "没有网络，不检查禅道 BUG 或 TASK"
            exit 0
        fi
        if echo "${_RST}" | grep -vw "success" &>/dev/null; then
            ZT_LOGIN_OK=0
            log_error_exit $ERR_LOGIN
        else
            ZT_LOGIN_OK=1
            log_info "Login zentao OK [ ${ZT_USER} ]"
        fi
    fi
}

# 获取登录session
do_get_session(){
    log_debug "get session action begin"
    _RST=`$(_curl_bin) GET "$ZT_HOST?m=api&f=getSessionID&t=json"`
    if [[ -z $_RST ]];then
        log_info "没有网络，不检查禅道 BUG 或 TASK"
        exit 0
    fi
    # log_debug $_RST
    if echo "${_RST}" | grep -vw "success" &>/dev/null; then
        log_error_exit ${ERR_SESSION_RST}
    fi
    ZT_SESSION_NAME=$(_parse_json_value_by_key $_RST "sessionName")
    log_debug "GET SESSION NAME: $ZT_SESSION_NAME"
    ZT_SESSION=$(_parse_json_value_by_key $_RST "sessionID")
    log_debug "GET SESSION ID: $ZT_SESSION"
    if [[ $ZT_SESSION_NAME == "" || $ZT_SESSION == "" ]]; then
        log_error_exit ${ERR_SESSION_DATA}
    fi
}

# rawurlencode() {
#   local string="${1}"
#   local strlen=${#string}
#   local encoded=""
#   local pos c o

#   for (( pos=0 ; pos<strlen ; pos++ )); do
#      c=${string:$pos:1}
#      case "$c" in
#         [-_.~a-zA-Z0-9] ) o="${c}" ;;
#         # * )               printf -v o '%%%02x' "'$c"
#         * )  o=`echo "$c" | tr -d '\n' | xxd -plain | sed 's/\(..\)/%\1/g'`
#      esac
#      encoded+="${o}"
#   done
#   echo "${encoded}"    # You can either set a return variable (FASTER) 
# #   REPLY="${encoded}"   #+or echo the result (EASIER)... or both... :p
# }

# perl_en(){
#     echo $(echo "$1" | sed -e 's/%/%25/g' -e 's/ /%20/g' -e 's/!/%21/g' -e 's/"/%22/g' -e 's/#/%23/g' -e 's/\$/%24/g' -e 's/\&/%26/g' -e 's/'\''/%27/g' -e 's/(/%28/g' -e 's/)/%29/g' -e 's/\*/%2a/g' -e 's/+/%2b/g' -e 's/,/%2c/g' -e 's/-/%2d/g' -e 's/\./%2e/g' -e 's/\//%2f/g' -e 's/:/%3a/g' -e 's/;/%3b/g' -e 's//%3e/g' -e 's/?/%3f/g' -e 's/@/%40/g' -e 's/\[/%5b/g' -e 's/\\/%5c/g' -e 's/\]/%5d/g' -e 's/\^/%5e/g' -e 's/_/%5f/g' -e 's/`/%60/g' -e 's/{/%7b/g' -e 's/|/%7c/g' -e 's/}/%7d/g' -e 's/~/%7e/g')
# }

# urlEncode(){
#   encoded_str=`echo "$*" | awk '
#     BEGIN {
#     split ("1 2 3 4 5 6 7 8 9 A B C D E F", hextab, " ")
#     hextab [0] = 0
#     for ( i=1; i<=255; ++i ) ord [ sprintf ("%c", i) "" ] = i + 0
#     }
#     {
#     encoded = ""
#     for ( i=1; i<=length ($0); ++i ) {
#         c = substr ($0, i, 1)
#         if ( c ~ /[a-zA-Z0-9.-]/ ) {
#         encoded = encoded c        # safe character
#         } else if ( c == " " ) {
#         encoded = encoded "+"    # special handling
#         } else {
#         # unsafe character, encode it as a two-digit hex-number
#         lo = ord [c] % 16
#         hi = int (ord [c] / 16);
#         encoded = encoded "%" hextab [hi] hextab [lo]
#         }
#     }
#         print encoded
#     }
# ' `
# }

# urlencodeaaa() {
#     # urlencode <string>

#     # old_lang=$LANG
#     # LANG=C
    
#     # old_lc_collate=$LC_COLLATE
#     # LC_COLLATE=C

#     local length="${#1}"
#     for (( i = 0; i < length; i++ )); do
#         local c="${1:i:1}"
#         case $c in
#             [a-zA-Z0-9.~_-]) printf "$c" ;;
#             *) printf '%%%02X' "'$c" ;;
#         esac
#     done

#     # LANG=$old_lang
#     # LC_COLLATE=$old_lc_collate
# }

# test_run(){
    # COMMIT_CONTENT=`cat ${COMMIT_MSG_FILE}`
    # DD="work[1]=${COMMIT_CONTENT}"
    # DD="id[1]=1&dates[1]=$(_date_time)&objectType[1]=task&consumed[1]=11&left[1]=11&objectID[1]=11&work[1]=${COMMIT_CONTENT}"
    # D="style (#9761-1-1): 中中"
    # log_debug $D
    # log_debug $D_D
    # log_debug $D_DD
    # D_D="$(perl -MURI::Escape -e 'print uri_escape(join(" ",@ARGV));' "$D")"
    # log_debug $D_D
    # log_debug $(_url_encode $D)
    # log_debug $(urlencodeaaa $DD)
    # urlEncode $D
    # log_debug $encoded_str
# }
#######################################################################

main(){
    validator
    # test_run
    # log_error_exit "main->${ERR_DEBUG}"
}

main
exit 0
